package redis

// https://gist.github.com/garyburd/c3219db8194841adff6f97f5dec28f60

import (
	"fmt"
	"log"
	"time"

	"github.com/gomodule/redigo/redis"
)

var pipeRunner *runner

func doCommand(cmd string, args ...interface{}) <-chan result {
	c := command{name: cmd, args: args, result: make(chan result, 1)}
	pipeRunner.send <- c

	return c.result
}

type command struct {
	name   string
	args   []interface{}
	result chan result
}

type result struct {
	err   error
	value interface{}
}

type recvWrap struct {
	args     interface{}
	callback func(interface{}) interface{}
	res      chan result
}

type runner struct {
	conn redis.Conn
	send chan command
	recv chan chan result
	//recv chan recvWrap
	stop chan struct{}
	done chan struct{}
}

func (r *runner) sender() {
	var flush int
	ticker := time.NewTicker(time.Second * 10)
	for {
		select {
		case <-r.stop:
			if err := r.conn.Flush(); err != nil {
				log.Fatal(err)
			}
			close(r.recv)
			fmt.Println("FLUSH", flush)
			return
		case cmd := <-r.send:
			if err := r.conn.Send(cmd.name, cmd.args...); err != nil {
				log.Fatal(err)
			}
			// Flush if the send queue is empty or the result queue is full.
			if len(r.send) == 0 || len(r.recv) == cap(r.recv) {
				flush++
				if err := r.conn.Flush(); err != nil {
					log.Fatal(err)
				}
			}
			r.recv <- cmd.result
		case <-ticker.C:
			if err := r.conn.Flush(); err != nil {
				log.Fatal(err)
			}
		}
	}
}

func (r *runner) receiver() {
	for ch := range r.recv {
		var result result
		result.value, result.err = r.conn.Receive()
		ch <- result
		// 发送完立即关闭
		close(ch)
		if result.err != nil && r.conn.Err() != nil {
			log.Fatal(r.conn.Err())
		}
	}
	close(r.done)
}

func newRunner() *runner {
	r := &runner{
		conn: redisPool.Get(),
		send: make(chan command, 4096),
		recv: make(chan chan result, 4096),
		stop: make(chan struct{}),
		done: make(chan struct{}),
	}
	go r.sender()
	go r.receiver()
	return r
}

func InitRedisPipeline(c *Config) {
	redisPool = newPool(c)
	pipeRunner := newRunner()
}

//func main() {
//	totalRequests := flag.Int("n", 100000, "Total number of `requests`")
//	flag.Parse()
//	r := newRunner()

//
//	start := time.Now()
//	args := []interface{}{"a", "b"}
//	for i := 0; i < *totalRequests; i++ {
//		r.send <- command{name: "SET", args: args, result: make(chan result, 1)}
//	}
//	close(r.stop)
//	<-r.done
//	t := time.Since(start)
//	fmt.Printf("%d requests completed in %f seconds\n", *totalRequests, float64(t)/float64(time.Second))
//	fmt.Printf("%f requests / second\n", float64(*totalRequests)*float64(time.Second)/float64(time.Since(start)))
//}
